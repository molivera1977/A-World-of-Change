<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A World of Change - Grouped Vocabulary Games</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .nav-container {
            padding: 30px;
            background: #f8f9fa;
        }

        .section {
            margin-bottom: 40px;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .section-title {
            font-size: 1.8em;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            padding: 15px;
            border-radius: 10px;
        }

        .word-challenges .section-title {
            background: linear-gradient(45deg, #ff7675, #e84393);
            color: white;
        }

        .definition-challenges .section-title {
            background: linear-gradient(45deg, #00b894, #00cec9);
            color: white;
        }

        .speech-test .section-title {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            color: white;
        }

        .game-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .game-btn {
            padding: 15px 25px;
            font-size: 1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            min-width: 180px;
        }

        .game-a {
            background: linear-gradient(45deg, #ff7675, #e84393);
        }

        .game-b {
            background: linear-gradient(45deg, #00b894, #00cec9);
        }

        .test-speech-btn {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
        }

        .game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .game-container {
            display: none;
            margin-top: 20px;
        }

        .timer-display {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            background: #fff;
            border: 3px solid #74b9ff;
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .timer-display.warning {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .timer-display.danger {
            border-color: #dc3545;
            background: #f8d7da;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .words-column, .definitions-column {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .column-title {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background: #e9ecef;
            border-radius: 8px;
        }

        .word-card, .definition-card {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            text-align: center;
            position: relative;
        }

        .speak-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .speak-btn:hover {
            background: #138496;
            transform: scale(1.1);
        }

        .speak-btn:active {
            background: #0f6674;
            transform: scale(0.95);
        }

        .speak-btn.speaking {
            background: #28a745;
            animation: speaking-pulse 0.5s infinite alternate;
        }

        @keyframes speaking-pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.15); }
        }

        .word-card:hover, .definition-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .word-card.selected {
            background: #fff3cd;
            border-color: #ffc107;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .definition-card.selected {
            background: #d1ecf1;
            border-color: #17a2b8;
            box-shadow: 0 0 10px rgba(23, 162, 184, 0.5);
        }

        .word-card.matched, .definition-card.matched {
            background: #d4edda;
            border-color: #28a745;
            opacity: 0.7;
            pointer-events: none;
        }

        .word-card.incorrect, .definition-card.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .match-celebration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 1000;
            animation: celebrationPop 1s ease-out;
            pointer-events: none;
        }

        @keyframes celebrationPop {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffc107;
            animation: confetti-fall 2s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% {
                opacity: 1;
                transform: translateY(-100px) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateY(100px) rotate(360deg);
            }
        }

        .game-controls {
            text-align: center;
            margin: 20px 0;
        }

        .control-btn {
            padding: 12px 25px;
            margin: 0 10px;
            font-size: 1em;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .reset-btn {
            background: linear-gradient(45deg, #fd79a8, #e84393);
            color: white;
        }

        .hint-btn {
            background: linear-gradient(45deg, #fdcb6e, #e17055);
            color: white;
        }

        .pause-btn {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
            color: white;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .score-display {
            text-align: center;
            font-size: 1.3em;
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 10px;
            color: #495057;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #00b894, #00cec9);
            width: 0%;
            transition: width 0.5s ease;
        }

        .celebration {
            display: none;
            text-align: center;
            padding: 30px;
            background: linear-gradient(45deg, #fd79a8, #fdcb6e);
            color: white;
            border-radius: 15px;
            margin: 20px 0;
            font-size: 1.5em;
            animation: bounce 1s infinite alternate;
        }

        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-10px); }
        }

        .speech-status {
            margin: 10px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 8px;
            font-size: 0.9em;
            text-align: center;
        }

        .speech-status.supported {
            background: #d4edda;
            color: #155724;
        }

        .speech-status.not-supported {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .game-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .game-btn {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç A World of Change</h1>
            <p>Grouped Vocabulary Flashcard Games</p>
        </div>

        <div class="nav-container">
            <!-- Speech Test Section -->
            <div class="section speech-test">
                <div class="section-title">üîä Speech Test</div>
                <div id="speechStatus" class="speech-status">Checking speech synthesis support...</div>
                <div class="game-controls">
                    <button class="control-btn test-speech-btn" onclick="testSpeech()">üé§ Test Speech</button>
                </div>
            </div>

            <!-- Word Challenges Section -->
            <div class="section word-challenges">
                <div class="section-title">üìù Word Challenges - Match Words to Definitions</div>
                <div class="game-buttons">
                    <button class="game-btn game-a" onclick="startGame('vocab1a', 'gameA')">üåç Vocab 1 Part A</button>
                    <button class="game-btn game-a" onclick="startGame('vocab1b', 'gameA')">üåç Vocab 1 Part B</button>
                    <button class="game-btn game-a" onclick="startGame('vocab2a', 'gameA')">üåã Vocab 2 Part A</button>
                    <button class="game-btn game-a" onclick="startGame('vocab2b', 'gameA')">üåã Vocab 2 Part B</button>
                    <button class="game-btn game-a" onclick="startGame('vocab3a', 'gameA')">‚ö° Vocab 3 Part A</button>
                    <button class="game-btn game-a" onclick="startGame('vocab3b', 'gameA')">‚ö° Vocab 3 Part B</button>
                </div>
            </div>

            <!-- Definition Challenges Section -->
            <div class="section definition-challenges">
                <div class="section-title">üìö Definition Challenges - Match Definitions to Words</div>
                <div class="game-buttons">
                    <button class="game-btn game-b" onclick="startGame('vocab1a', 'gameB')">üåç Vocab 1 Part A</button>
                    <button class="game-btn game-b" onclick="startGame('vocab1b', 'gameB')">üåç Vocab 1 Part B</button>
                    <button class="game-btn game-b" onclick="startGame('vocab2a', 'gameB')">üåã Vocab 2 Part A</button>
                    <button class="game-btn game-b" onclick="startGame('vocab2b', 'gameB')">üåã Vocab 2 Part B</button>
                    <button class="game-btn game-b" onclick="startGame('vocab3a', 'gameB')">‚ö° Vocab 3 Part A</button>
                    <button class="game-btn game-b" onclick="startGame('vocab3b', 'gameB')">‚ö° Vocab 3 Part B</button>
                </div>
            </div>

            <!-- Single Game Container -->
            <div id="game-container" class="game-container"></div>
        </div>
    </div>

    <script>
        // Enhanced vocabulary data split into parts
        const vocabularyData = {
            vocab1a: {
                constant: "happening all the time; never stopping",
                natural: "existing in or produced by nature; not made by humans",
                alter: "to change or modify something",
                surface: "the outside or top layer of something",
                effect: "a result or consequence of an action",
                weathering: "the process of rocks breaking down due to weather"
            },
            vocab1b: {
                erosion: "the wearing away of land by water, wind, or ice",
                deposition: "the process of dropping sediment in a new place",
                process: "a series of actions or steps taken to achieve a result",
                landform: "a natural feature of the earth's surface",
                collapse: "to fall down or break apart suddenly",
                substantial: "large in amount, size, or importance"
            },
            vocab2a: {
                although: "despite the fact that; even though",
                hazard: "a danger or risk that could cause harm",
                community: "a group of people living in the same area",
                structure: "something that has been built or organized",
                unfortunate: "unlucky or having bad consequences",
                destruction: "the action of destroying or being destroyed"
            },
            vocab2b: {
                eruption: "a sudden explosion or bursting forth",
                landslide: "when rocks and earth slide down a slope",
                pressure: "continuous force applied to something",
                warning: "a statement telling of possible danger",
                potential: "having the possibility to develop or happen",
                crisis: "a time of serious difficulty or danger"
            },
            vocab3a: {
                loosen: "to make or become less tight or firmly fixed",
                severe: "very serious, extreme, or harsh",
                contrast: "to compare showing differences",
                prevent: "to stop something from happening",
                disaster: "a sudden event causing great damage"
            },
            vocab3b: {
                event: "something that happens or takes place",
                unpredictable: "not able to be predicted or foreseen",
                evacuate: "to remove people from a place of danger",
                gradual: "happening slowly over time",
                swift: "happening quickly or fast"
            }
        };

        let currentGame = null;
        let selectedWord = null;
        let selectedDefinition = null;
        let matches = 0;
        let totalPairs = 0;
        let attempts = 0;
        let gameTimer = null;
        let startTime = null;
        let isPaused = false;
        let elapsedTime = 0;

        // Audio context for sound effects
        let audioContext;
        
        // Check speech synthesis support on page load
        window.addEventListener('load', checkSpeechSupport);

        function checkSpeechSupport() {
            const statusElement = document.getElementById('speechStatus');
            
            if ('speechSynthesis' in window) {
                statusElement.textContent = '‚úÖ Speech synthesis is supported! Click the speaker buttons to hear pronunciations.';
                statusElement.className = 'speech-status supported';
                
                // Load voices
                if (speechSynthesis.getVoices().length === 0) {
                    speechSynthesis.addEventListener('voiceschanged', () => {
                        console.log('Voices loaded:', speechSynthesis.getVoices().length);
                    });
                }
            } else {
                statusElement.textContent = '‚ùå Speech synthesis is not supported in your browser. Try Chrome, Firefox, Safari, or Edge.';
                statusElement.className = 'speech-status not-supported';
            }
        }

        function testSpeech() {
            if ('speechSynthesis' in window) {
                // Stop any ongoing speech
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance('Hello! This is a test of the speech feature. If you can hear this, the pronunciation buttons will work in the games.');
                
                // Configure speech settings
                utterance.rate = 0.8;
                utterance.pitch = 1;
                utterance.volume = 1;
                utterance.lang = 'en-US';
                
                // Get available voices
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    // Try to find a good English voice
                    const englishVoice = voices.find(voice => 
                        voice.lang.startsWith('en') && voice.default
                    ) || voices.find(voice => 
                        voice.lang.startsWith('en')
                    ) || voices[0];
                    
                    utterance.voice = englishVoice;
                    console.log('Using voice:', englishVoice.name, englishVoice.lang);
                }
                
                utterance.onstart = () => {
                    console.log('Speech started');
                    document.getElementById('speechStatus').textContent = 'üîä Speaking test message...';
                };
                
                utterance.onend = () => {
                    console.log('Speech ended');
                    document.getElementById('speechStatus').textContent = '‚úÖ Test complete! Did you hear the message? If yes, pronunciation is working.';
                };
                
                utterance.onerror = (event) => {
                    console.error('Speech error:', event.error);
                    document.getElementById('speechStatus').textContent = `‚ùå Speech error: ${event.error}. Try refreshing the page.`;
                };
                
                speechSynthesis.speak(utterance);
            } else {
                alert('Speech synthesis is not supported in your browser.');
            }
        }
        
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    console.log('AudioContext not supported:', error);
                }
            }
        }

        function playSuccessSound() {
            initAudio();
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (error) {
                console.log('Audio playback error:', error);
            }
        }

        function playCompletionSound() {
            initAudio();
            if (!audioContext) return;
            
            try {
                const notes = [523.25, 587.33, 659.25, 698.46, 783.99]; // C-D-E-F-G
                
                notes.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + index * 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.1 + 0.3);
                    
                    oscillator.start(audioContext.currentTime + index * 0.1);
                    oscillator.stop(audioContext.currentTime + index * 0.1 + 0.3);
                });
            } catch (error) {
                console.log('Audio playback error:', error);
            }
        }

        function speakText(text, button = null) {
            if ('speechSynthesis' in window) {
                // Stop any ongoing speech
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                
                // Configure speech settings for better pronunciation
                utterance.rate = 0.7; // Slower for clearer pronunciation
                utterance.pitch = 1;
                utterance.volume = 1;
                utterance.lang = 'en-US';
                
                // Get available voices and select a good one
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    // Try to find a good English voice
                    const englishVoice = voices.find(voice => 
                        voice.lang.startsWith('en') && 
                        (voice.name.includes('Google') || voice.name.includes('Microsoft') || voice.default)
                    ) || voices.find(voice => 
                        voice.lang.startsWith('en')
                    ) || voices[0];
                    
                    utterance.voice = englishVoice;
                }
                
                // Visual feedback
                if (button) {
                    button.classList.add('speaking');
                    button.innerHTML = 'üéµ';
                }
                
                utterance.onstart = () => {
                    console.log(`Speaking: ${text}`);
                };
                
                utterance.onend = () => {
                    console.log(`Finished speaking: ${text}`);
                    if (button) {
                        button.classList.remove('speaking');
                        button.innerHTML = 'üîä';
                    }
                };
                
                utterance.onerror = (event) => {
                    console.error(`Speech error for "${text}":`, event.error);
                    if (button) {
                        button.classList.remove('speaking');
                        button.innerHTML = '‚ùå';
                        setTimeout(() => {
                            button.innerHTML = 'üîä';
                        }, 1000);
                    }
                };
                
                speechSynthesis.speak(utterance);
            } else {
                alert('Speech synthesis is not supported in your browser. Please try Chrome, Firefox, Safari, or Edge.');
            }
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function updateTimer() {
            if (isPaused || !startTime) return;
            
            const currentTime = Date.now();
            const totalElapsed = elapsedTime + (currentTime - startTime);
            const seconds = Math.floor(totalElapsed / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            const timerDisplay = document.getElementById('timer');
            if (timerDisplay) {
                const timeString = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                timerDisplay.textContent = `‚è±Ô∏è Time: ${timeString}`;
                
                // Change color based on time
                timerDisplay.className = 'timer-display';
                if (seconds > 120) { // 2 minutes
                    timerDisplay.classList.add('danger');
                } else if (seconds > 90) { // 1.5 minutes
                    timerDisplay.classList.add('warning');
                }
            }
        }

        function startGameTimer() {
            startTime = Date.now();
            elapsedTime = 0;
            isPaused = false;
            if (gameTimer) clearInterval(gameTimer);
            gameTimer = setInterval(updateTimer, 1000);
        }

        function pauseTimer() {
            if (!isPaused && startTime) {
                elapsedTime += Date.now() - startTime;
                isPaused = true;
            }
        }

        function resumeTimer() {
            if (isPaused) {
                startTime = Date.now();
                isPaused = false;
            }
        }

        function stopTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            const finalTime = elapsedTime + (startTime ? Date.now() - startTime : 0);
            return Math.floor(finalTime / 1000);
        }

        function createConfetti(element) {
            const colors = ['#ffc107', '#28a745', '#17a2b8', '#dc3545', '#6f42c1', '#fd7e14'];
            
            for (let i = 0; i < 10; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = (Math.random() * 100) + '%';
                confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                element.appendChild(confetti);
                
                setTimeout(() => {
                    confetti.remove();
                }, 2000);
            }
        }

        function showMatchCelebration(element) {
            const celebration = document.createElement('div');
            celebration.className = 'match-celebration';
            celebration.textContent = ['Great!', 'Awesome!', 'Perfect!', 'Excellent!'][Math.floor(Math.random() * 4)];
            element.appendChild(celebration);
            
            setTimeout(() => {
                celebration.remove();
            }, 1000);
            
            createConfetti(element);
            playSuccessSound();
        }

        function startGame(vocabList, gameType) {
            // Hide any existing game
            const gameContainer = document.getElementById('game-container');
            gameContainer.style.display = 'block';
            gameContainer.innerHTML = '';

            currentGame = { vocabList, gameType };
            selectedWord = null;
            selectedDefinition = null;
            matches = 0;
            attempts = 0;

            const vocab = vocabularyData[vocabList];
            const words = Object.keys(vocab);
            const definitions = Object.values(vocab);
            totalPairs = words.length;

            let shuffledWords, shuffledDefinitions;
            let leftColumnTitle, rightColumnTitle;

            if (gameType === 'gameA') {
                shuffledWords = shuffleArray(words);
                shuffledDefinitions = shuffleArray(definitions);
                leftColumnTitle = "Words";
                rightColumnTitle = "Definitions";
            } else {
                shuffledDefinitions = shuffleArray(definitions);
                shuffledWords = shuffleArray(words);
                leftColumnTitle = "Definitions";
                rightColumnTitle = "Words";
            }

            const gameHTML = `
                <div class="timer-display" id="timer">‚è±Ô∏è Time: 00:00</div>
                
                <div class="score-display">
                    <div>Score: <span id="score">0</span> / ${totalPairs} | Attempts: <span id="attempts">0</span></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress"></div>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="control-btn reset-btn" onclick="resetGame()">üîÑ Reset Game</button>
                    <button class="control-btn hint-btn" onclick="showHint()">üí° Show Hint</button>
                    <button class="control-btn pause-btn" onclick="togglePause()" id="pauseBtn">‚è∏Ô∏è Pause</button>
                </div>

                <div class="game-area">
                    <div class="${gameType === 'gameA' ? 'words' : 'definitions'}-column">
                        <div class="column-title">${leftColumnTitle}</div>
                        <div id="left-column"></div>
                    </div>
                    <div class="${gameType === 'gameA' ? 'definitions' : 'words'}-column">
                        <div class="column-title">${rightColumnTitle}</div>
                        <div id="right-column"></div>
                    </div>
                </div>

                <div class="celebration" id="celebration">
                    üéâ Congratulations! You matched all pairs! üéâ
                    <br>You completed it in <span id="final-attempts"></span> attempts and <span id="final-time"></span>!
                </div>
            `;

            gameContainer.innerHTML = gameHTML;

            // Populate columns
            const leftColumn = document.getElementById('left-column');
            const rightColumn = document.getElementById('right-column');

            if (gameType === 'gameA') {
                shuffledWords.forEach(word => {
                    const card = createCard(word, 'word', word, word);
                    leftColumn.appendChild(card);
                });

                shuffledDefinitions.forEach(definition => {
                    const word = Object.keys(vocab).find(key => vocab[key] === definition);
                    const card = createCard(definition, 'definition', word, definition);
                    rightColumn.appendChild(card);
                });
            } else {
                shuffledDefinitions.forEach(definition => {
                    const word = Object.keys(vocab).find(key => vocab[key] === definition);
                    const card = createCard(definition, 'definition', word, definition);
                    leftColumn.appendChild(card);
                });

                shuffledWords.forEach(word => {
                    const card = createCard(word, 'word', word, word);
                    rightColumn.appendChild(card);
                });
            }

            startGameTimer();
        }

        function createCard(text, type, matchKey, audioText) {
            const card = document.createElement('div');
            card.className = `${type}-card`;
            card.dataset.match = matchKey;
            
            const textDiv = document.createElement('div');
            textDiv.textContent = text;
            card.appendChild(textDiv);
            
            // Add audio button to all cards
            const speakBtn = document.createElement('button');
            speakBtn.className = 'speak-btn';
            speakBtn.innerHTML = 'üîä';
            speakBtn.title = 'Listen to audio';
            speakBtn.onclick = (e) => {
                e.stopPropagation();
                speakText(audioText, speakBtn);
            };
            card.appendChild(speakBtn);
            
            card.addEventListener('click', () => selectCard(card, type));
            return card;
        }

        function selectCard(card, type) {
            if (card.classList.contains('matched') || isPaused) return;

            // Clear previous incorrect states
            document.querySelectorAll('.word-card, .definition-card').forEach(c => {
                c.classList.remove('incorrect');
            });

            if (type === 'word') {
                // Deselect other words
                document.querySelectorAll('.word-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedWord = card;
            } else {
                // Deselect other definitions
                document.querySelectorAll('.definition-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedDefinition = card;
            }

            // Check for match if both are selected
            if (selectedWord && selectedDefinition) {
                attempts++;
                document.getElementById('attempts').textContent = attempts;

                if (selectedWord.dataset.match === selectedDefinition.dataset.match) {
                    // Match found!
                    selectedWord.classList.add('matched');
                    selectedDefinition.classList.add('matched');
                    selectedWord.classList.remove('selected');
                    selectedDefinition.classList.remove('selected');
                    
                    // Show celebration
                    showMatchCelebration(selectedWord);
                    
                    matches++;
                    document.getElementById('score').textContent = matches;
                    
                    const progress = (matches / totalPairs) * 100;
                    document.getElementById('progress').style.width = progress + '%';
                    
                    if (matches === totalPairs) {
                        const finalTimeSeconds = stopTimer();
                        const minutes = Math.floor(finalTimeSeconds / 60);
                        const seconds = finalTimeSeconds % 60;
                        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        
                        setTimeout(() => {
                            document.getElementById('final-attempts').textContent = attempts;
                            document.getElementById('final-time').textContent = timeString;
                            document.getElementById('celebration').style.display = 'block';
                            playCompletionSound();
                        }, 500);
                    }
                    
                    selectedWord = null;
                    selectedDefinition = null;
                } else {
                    // No match
                    selectedWord.classList.add('incorrect');
                    selectedDefinition.classList.add('incorrect');
                    
                    setTimeout(() => {
                        if (selectedWord && selectedDefinition) {
                            selectedWord.classList.remove('selected', 'incorrect');
                            selectedDefinition.classList.remove('selected', 'incorrect');
                            selectedWord = null;
                            selectedDefinition = null;
                        }
                    }, 1000);
                }
            }
        }

        function togglePause() {
            const pauseBtn = document.getElementById('pauseBtn');
            if (isPaused) {
                resumeTimer();
                pauseBtn.innerHTML = '‚è∏Ô∏è Pause';
            } else {
                pauseTimer();
                pauseBtn.innerHTML = '‚ñ∂Ô∏è Resume';
            }
        }

        function resetGame() {
            if (gameTimer) clearInterval(gameTimer);
            if (currentGame) {
                startGame(currentGame.vocabList, currentGame.gameType);
            }
        }

        function showHint() {
            if (isPaused) {
                alert('‚è∏Ô∏è Game is paused. Resume to use hints!');
                return;
            }
            
            if (!selectedWord && !selectedDefinition) {
                alert('üí° Select a card first, then I\'ll highlight its match!');
                return;
            }

            const selectedCard = selectedWord || selectedDefinition;
            const matchKey = selectedCard.dataset.match;
            
            // Find and highlight the matching card
            const allCards = document.querySelectorAll('.word-card, .definition-card');
            allCards.forEach(card => {
                if (card !== selectedCard && card.dataset.match === matchKey && !card.classList.contains('matched')) {
                    card.style.background = '#fff3cd';
                    card.style.border = '3px solid #ffc107';
                    card.style.boxShadow = '0 0 15px rgba(255, 193, 7, 0.8)';
                    
                    setTimeout(() => {
                        card.style.background = '';
                        card.style.border = '';
                        card.style.boxShadow = '';
                    }, 2000);
                }
            });
        }

        // Initialize audio context on first user interaction
        document.addEventListener('click', initAudio, { once: true });
    </script>
</body>
</html>